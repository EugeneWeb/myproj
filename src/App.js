import { BrowserRouter as Router, Routes, Route } from "react-router-dom";

import s from "./App.module.css";

import Header from "./components/Header/Header";
import NavBar from "./components/NavBar/NavBar";

import Profile from "./components/Profile/Profile";
import News from "./components/News/News";
import Music from "./components/Music/Music";
import Settings from "./components/Settings/Settings";
import Error from "./components/Error/Error";
import DialogsContainer from "./components/Dialogs/DialogsContainer";


// Уст react-redux, Provider, connect, (имьютабильность(перевод), детерминированность, идемпотентность, side effects в чистых функциях), какие в нашей программе функции явл чистыми(почему неправильно), как наз-ся объявл объектов и масси через [], {}, почему 2 люб объекта, даже с одинак знач не равны(отлич от примитивов)
// npm i react-redux

// Первая основная проблема передача - объекта store
// Решается с помощью тега Provider(примерно такой же, какой делали мы: т.е скрывает работы с контекстом, но по функциональней)

// Удаляем импорты StoreContext.Provider, теперь вместо него Provider
// Далее Заменяем StoreContext.Consumer на более удобную функцию connect
// Функция connect возвращает контейнерную компоненту, которая render'ит презентационную компоненту
// Для работы с данной функцией используем следующий синтаксис:
// 
// mapStateToProps - замапить(сопоставить) state с пропсами(map to - сопоставить с)
// const mapStateToProps = (state) => {
//     return { 
//         dialogsPage: state.dialogsPage
//     }
// }
// 
// mapDispatchToProps сопоставить dispatch с пропсами
// const mapDispatchToProps = (dispatch) => {
//     return {
//         sendMessage: () => {
//             dispatch(actionCreator())
//         }
//     }
// }
// const DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(Dialogs)
// Т.е мы вызываем данную функцию 2 раза, первый раз мы передаём в неё 2 колбэка
// колбэки mapStateToProps и mapDispatchToProps позволяют перейти от работы с ООП объектом store к функциональному программированию(обе возвращают объекты): 
// mapStateToProps - функция, которая передаёт state из объекта store(по сути подкапотом вызывается            store.getState()), возвращает данные из state, которые мы используем в презентационной компоненте
// mapDispatchToProps - функция, которая передаёт метод dispatch с забиндиным(привязанным) контекстом store из объекта store, возвращает колбэк функции, которые мы используем в презентационной компоненте
// Первый вызов служит для передачи 2-ух объектов, свойства и методы которых будут переданы в презентационную компоненту, которую мы укажем при втором вызове


// Но даже после этого не заработает, state будет изменяться(можно посмотреть через window), но render'а происходить не будет
// Для объяснения этого обратимся к чистым функциям и их свойствам
// Детерминированность - чистая функция при одинаковых входных значениях должна вовращать одинаковый результат
// Идемпотентность - чистая функция должна возвращать один и тот же результат при одинаковых входных данных независимо от количества вызовов
// Чистые функции не должны содержать side effects(побочные эффекты): т.е не работают с c внешними ресурсами: глобальными переменными, работа с файлами(запись), работа с БД
// Имьютабильность - неизменяемость, т.е чистая функция не имеет права изменять данные, которые к ней пришли(т.е если мы имеем дело с внешним объектом, то для его изменения создаем копию)

// В нашей программе чистыми функциями являются reducer'ы и компоненты
// Поэтому наша прошлая работа со state'ом напрямую и его изменение - ошибка
// Мы должны создать копию stateCopy и работать с ней
// Если мы сделаем так, то наша программа заработает, но почему?
// Потому что, в таком случае у нас ссылки составных частей state будут изменяться и таким образом функция connect поймёт(при сравнении прошлого), что данные были обновлены и запустит свою функцию render для конкретного компонента(т.е как это происходит: каждый раз при изменении state'а функция map сравнивает данные, которые возвращает mapStateToProps с прошлыми данными и если данные(ссылки на объекты)(под данными подразумеваю те свойства, кот-ые содержаться в объекте возвращаемом mapStateToProps) совпадают, то ничего не происходит, если не совпадают, то происходит render компонента)

// Также нужно учитывать, что функция connect сама отвечает за работу с render'ом компонента и внутри себя сама вызывает метод subscribe(поэтому мы и убираем rerenderEntireTree), таким образом происходит более оптимизированный render'инг определенного компонента, а не всего app в целом)

// как наз-ся объявл объектов и масси через [], {}, почему 2 люб объекта, даже с одинак знач не равны(отлич от примитивов)
// Объявление объекта через {} - это объявление объекта через литерал объекта
// Объявление массива через [] - это объявление массива через литерал массива
// 2 любых объекта не равны
// {} === {} false
// {} == {} false
// {name: 'Alex'} === {name: 'Alex'} false
// {name: 'Alex'} == {name: 'Alex'} false
// Это связано с тем, что при сравнении объектов происходит сравнение их ссылок, а так как объекты, объявленные через литерал объекта имеют разные ссылки, то они не равны
// Примитивы сравниваются по значению, объекты по ссылке

function App(props) {
    return (
        <Router>
            <div className={s.wrap}>
                <Header />
                <NavBar />
                <div className={s.content}>
                    <Routes>
                        <Route path="/profile" element={<Profile />} />
                        <Route path="/news" element={<News />} />
                        <Route path="/messages/*" element={<DialogsContainer />} />
                        <Route path="/music" element={<Music />} />
                        <Route path="/settings" element={<Settings />} />

                        <Route path="*" element={<Error />} />
                    </Routes>
                </div>
            </div>
        </Router>
    );
}

export default App;
